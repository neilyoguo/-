
# 设计模式

## 单例模式
单例模式是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。
### 有了全局变量为什么还要单例模式？

全局变量和单例模式都可以用于在程序中创建全局唯一的对象，但它们的实现方式和应用场景有所不同。\
全局变量是一种简单的方式来表示在整个程序中只需要存在一个实例的对象。但是，全局变量可能会导致命名空间污染和代码的可维护性问题。\
单例模式是一种设计模式，它提供了一种更加灵活和可控的方式来创建全局唯一的对象。它通过将对象的创建和访问进行封装，从而避免了全局变量的问题。此外，单例模式还可以提供一些额外的特性，比如懒加载和线程安全等。
因此，尽管全局变量可以实现类似的功能，但在需要更加优雅和可维护的代码时，单例模式是更好的选择。
### 单例模式适合应用场景
程序中的某个类对于所有客户只有一个可用的实例， 可以使用单例模式。\
比如：windows 任务管理器只能打开一个
### 饿汉模式
饿汉模式就是在类加载的时候立刻进行实例化，这样就得到了一个唯一的可用对象，是线程安全的。
### 懒汉模式
懒汉模式是在类加载的时候不去创建这个唯一的实例，而是在需要使用的时候再进行实例化，是线程不安全的。
### 实现方式
* 将默认构造函数设为私有， 防止对象使用new运算符。
* 将拷贝构造和运算符禁用， 防止对象拷贝。
* 创建一个静态方法来获取相同的对象。


懒汉模式实现，见[demo1](https://github.com/neilyoguo/Design-Patterns-/tree/main/demo1)

***
## 原型模式
原型模式（Prototype Pattern）是一种创建型设计模式，它允许通过复制现有的对象来创建新的对象，而不是通过实例化一个类来创建对象。原型模式基于一个原型对象来创建新的对象，新对象会拥有原型对象的所有属性和方法，同时也可以根据需要进行自定义修改。\
在原型模式中，原型对象通常是通过克隆方法来实现的。该方法会创建一个新的对象，并将原型对象的属性值复制到新对象中。克隆方法可以是浅克隆或深克隆，浅克隆只会复制对象的基本数据类型属性，而深克隆会复制对象的所有属性，包括引用类型属性。\
原型模式可以避免重复创建相似对象的开销，提高对象创建的效率。它适用于那些需要创建大量相似对象的场景，例如在图形界面应用程序中，可以使用原型模式来创建复杂的用户界面元素。但是需要注意的是，在使用原型模式时，原型对象必须是可复制的，否则无法使用该模式。

### 原型模式适合应用场景
如果需要创建大量相似的对象，可以使用原型模式\
比如：现实生活中的复制钥匙

### 有了拷贝构造为什么还要原型模式？
原型模式实现的是一个clone接口，基于多态的clone虚函数。也就是说原型模式能够通过基类指针来复制派生类对象。拷贝构造函数完不成这样的任务。\
尽管拷贝构造函数可以用于创建对象的副本，但原型模式提供了一种更加灵活的方式来创建对象，它可以通过克隆现有的对象来创建新对象，而无需了解对象的具体实现细节。这种方式可以避免在创建对象时的重复性工作，并且能够在运行时动态地添加或删除对象。因此，原型模式在某些情况下比拷贝构造函数更加适合，尤其是在需要频繁创建相似对象时，或者需要动态创建对象时。

### 实现方式
* 父类提供clone接口
* 派生类实现clone函数
* 通过父类指针指向子类对象实现clone

原型模式实现，见[demo2](https://github.com/neilyoguo/Design-Patterns-/tree/main/demo2)
***


## 简单工厂模式
简单工厂模式是一种创建型设计模式，其目的是封装对象的创建过程，使得客户端代码无需知道具体的对象创建细节，只需要提供所需的参数即可获取对象。\
简单工厂模式通常由一个工厂类来实现，这个工厂类根据客户端传入的参数来判断应该创建哪种类型的对象，并返回相应的对象实例。客户端只需要调用工厂类的方法，传入所需的参数，就可以获取所需的对象实例。

简单工厂模式实现，见[demo3](https://github.com/neilyoguo/Design-Patterns-/tree/main/demo3)
### 缺陷
从demo3中可以看出，当我们需要增加一种新的类型对象时，不仅需要增加一产品对象类，还需要修改工厂类的代码，不够灵活
***
## 工厂方法模式
工厂方法模式是一种创建型设计模式，它定义了一个用于创建对象的接口，但具体创建哪个对象由子类决定。在工厂方法模式中，创建对象的方法通常被定义在一个抽象工厂类中，而具体的工厂则继承自抽象工厂类，并实现其创建对象的方法。这样可以让客户端代码通过调用工厂方法来创建对象，而不需要知道具体的实现细节。
### 与简单工厂的区别
工厂方法模式能够提供更高的灵活性和可扩展性，将工厂类抽象出来，增加新的产品只需要增加相应的工厂类和产品类即可。

工厂方法模式实现，见[demo4](https://github.com/neilyoguo/Design-Patterns-/tree/main/demo4)
### 缺陷
从demo4中可以看出，当我们需要增加一种新的类型对象时，需要创建产品类，还要创建工厂类。工厂方法模式可能会导致创建大量的工厂类
***

## 抽象工厂模式
在抽象工厂模式中，有一个抽象工厂类，它定义了一套用于创建一组抽象产品的方法，而具体的工厂类则负责实现这些方法，创建具体的产品对象。每个具体的工厂类对应一种具体的产品族，也就是一组相关联的产品。\
抽象工厂模式实现，见[demo5](https://github.com/neilyoguo/Design-Patterns-/tree/main/demo5)

抽象工厂、简单工厂和工厂方法都是创建对象的设计模式，它们的区别如下：
* 简单工厂：由一个工厂类根据传入的参数来决定创建哪种产品类的实例。这种设计模式只有一个工厂类，适合用于创建的对象较少的情况。
* 工厂方法：定义一个用于创建对象的接口，让子类决定实例化哪个类。这种设计模式有一个抽象工厂类，每个具体的工厂类都继承自抽象工厂类，用于创建特定类型的产品。
* 抽象工厂：提供一个接口，用于创建一系列相关或相互依赖的对象。这种设计模式有一个或多个抽象工厂类，每个具体的工厂类都继承自抽象工厂类，用于创建一系列相关的产品。
* 简单工厂适合用于创建的对象较少的情况，而工厂方法和抽象工厂则适合创建多个相关的对象。工厂方法比抽象工厂更加灵活，因为它只需要实现一个抽象方法，而不是多个。
***
## 观察者模式
观察者模式是一种设计模式，也称为发布-订阅模式（Publish-Subscribe Pattern）。它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象，当主题对象状态发生变化时，它会自动通知所有观察者，使它们能够及时进行相应的处理。\
观察者模式包含以下角色：
* 观察者：当事件状态发生变化时，它会接收到通知并进行相应的处理。
所以观察者类至少有一个响应事件的函数
```
class Observer
{
    //事件响应
    void update(string action);
}
```
* 被观察者：具体的被观察对象，需要维护观察者列表，通知观察者。

所以被观察者类至少有以下函数
```
class Subject
{
    //添加观察者
    void AddObserver(Observer *ob)；
    //删除观察者
    void DelObserver(Observer *ob);
    //事件通知
    void Notitf(std::string action);
}
```
见[demo6](https://github.com/neilyoguo/Design-Patterns-/tree/main/demo6),demo6是一个简单的观察者模式，老师作为被观察者，学生作为观察者。\
但是实际上，学生可能会做出各种各样的响应（比如：睡觉，玩手机，听音乐等），老师也可能为各种各样老师（比如：班主任，教务处主任，校长等），所以可以把老师和学生抽象出来\
见[demo7](https://github.com/neilyoguo/Design-Patterns-/tree/main/demo7)


