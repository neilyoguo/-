
# 设计模式

## 单例模式
单例模式是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。
### 有了全局变量为什么还要单例模式？

全局变量和单例模式都可以用于在程序中创建全局唯一的对象，但它们的实现方式和应用场景有所不同。\
全局变量是一种简单的方式来表示在整个程序中只需要存在一个实例的对象。但是，全局变量可能会导致命名空间污染和代码的可维护性问题。\
单例模式是一种设计模式，它提供了一种更加灵活和可控的方式来创建全局唯一的对象。它通过将对象的创建和访问进行封装，从而避免了全局变量的问题。此外，单例模式还可以提供一些额外的特性，比如懒加载和线程安全等。
因此，尽管全局变量可以实现类似的功能，但在需要更加优雅和可维护的代码时，单例模式是更好的选择。
### 单例模式适合应用场景
程序中的某个类对于所有客户只有一个可用的实例， 可以使用单例模式。\
比如：windows 任务管理器只能打开一个
### 饿汉模式
饿汉模式就是在类加载的时候立刻进行实例化，这样就得到了一个唯一的可用对象，是线程安全的。
### 懒汉模式
懒汉模式是在类加载的时候不去创建这个唯一的实例，而是在需要使用的时候再进行实例化，是线程不安全的。
### 实现方式
* 将默认构造函数设为私有， 防止对象使用new运算符。
* 将拷贝构造和运算符禁用， 防止对象拷贝。
* 创建一个静态方法来获取相同的对象。


懒汉模式实现，见demo1[https://github.com/neilyoguo/Design-Patterns-/tree/main/demo1]

## 原型模式
原型模式（Prototype Pattern）是一种创建型设计模式，它允许通过复制现有的对象来创建新的对象，而不是通过实例化一个类来创建对象。原型模式基于一个原型对象来创建新的对象，新对象会拥有原型对象的所有属性和方法，同时也可以根据需要进行自定义修改。\
在原型模式中，原型对象通常是通过克隆方法来实现的。该方法会创建一个新的对象，并将原型对象的属性值复制到新对象中。克隆方法可以是浅克隆或深克隆，浅克隆只会复制对象的基本数据类型属性，而深克隆会复制对象的所有属性，包括引用类型属性。\
原型模式可以避免重复创建相似对象的开销，提高对象创建的效率。它适用于那些需要创建大量相似对象的场景，例如在图形界面应用程序中，可以使用原型模式来创建复杂的用户界面元素。但是需要注意的是，在使用原型模式时，原型对象必须是可复制的，否则无法使用该模式。

### 原型模式适合应用场景
如果需要创建大量相似的对象，可以使用原型模式\
比如：现实生活中的复制钥匙

### 有了拷贝构造为什么还要原型模式？
原型模式实现的是一个clone接口，基于多态的clone虚函数。也就是说原型模式能够通过基类指针来复制派生类对象。拷贝构造函数完不成这样的任务。\
尽管拷贝构造函数可以用于创建对象的副本，但原型模式提供了一种更加灵活的方式来创建对象，它可以通过克隆现有的对象来创建新对象，而无需了解对象的具体实现细节。这种方式可以避免在创建对象时的重复性工作，并且能够在运行时动态地添加或删除对象。因此，原型模式在某些情况下比拷贝构造函数更加适合，尤其是在需要频繁创建相似对象时，或者需要动态创建对象时。

### 实现方式
* 父类提供clone接口
* 派生类实现clone函数
* 通过父类指针指向子类对象实现clone

原型模式实现，见demo2[https://github.com/neilyoguo/Design-Patterns-/tree/main/demo2]